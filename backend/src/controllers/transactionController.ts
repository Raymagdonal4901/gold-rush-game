import { Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import WithdrawalRequest from '../models/WithdrawalRequest';
import DepositRequest from '../models/DepositRequest';
import ClaimRequest from '../models/ClaimRequest';
import Rig from '../models/Rig';
import User from '../models/User';

// ... (Existing imports)

// Create Deposit Request (User)
// ... (Existing code)

// Create Withdrawal Request (User)
export const createWithdrawalRequest = async (req: AuthRequest, res: Response) => {
    try {
        const { amount } = req.body;
        const userId = req.userId;

        if (!amount || amount <= 0) {
            return res.status(400).json({ message: 'Invalid amount' });
        }

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        if (user.balance < amount) {
            return res.status(400).json({ message: 'Insufficient balance' });
        }

        // Deduct balance immediately upon request
        user.balance -= amount;
        await user.save();

        const withdrawal = await WithdrawalRequest.create({
            userId,
            username: user.username,
            amount,
            status: 'PENDING'
        });

        res.status(201).json({ message: 'Withdrawal requested', withdrawal, newBalance: user.balance });
    } catch (error) {
        res.status(500).json({ message: 'Server error', error });
    }
};

// Get My Transaction History (Deposit & Withdrawal)
export const getMyHistory = async (req: AuthRequest, res: Response) => {
    try {
        const deposits = await DepositRequest.find({ userId: req.userId }).lean();
        const withdrawals = await WithdrawalRequest.find({ userId: req.userId }).lean();

        // Combine and sort by date
        const history = [
            ...deposits.map(d => ({ ...d, type: 'DEPOSIT' })),
            ...withdrawals.map(w => ({ ...w, type: 'WITHDRAWAL' }))
        ].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

        res.json(history);
    } catch (error) {
        res.status(500).json({ message: 'Server error', error });
    }
};

// Get My Deposit History (User)
export const getMyDeposits = async (req: AuthRequest, res: Response) => {
    try {
        const deposits = await DepositRequest.find({ userId: req.userId }).sort({ createdAt: -1 });
        res.json(deposits);
    } catch (error) {
        res.status(500).json({ message: 'Server error', error });
    }
};
export const createDepositRequest = async (req: AuthRequest, res: Response) => {
    try {
        const { amount, slipImage } = req.body;
        const userId = req.userId;

        if (!amount || !slipImage) {
            return res.status(400).json({ message: 'Amount and Slip Image are required' });
        }

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const deposit = await DepositRequest.create({
            userId,
            username: user.username,
            amount,
            slipImage,
            status: 'PENDING'
        });

        res.status(201).json(deposit);
    } catch (error) {
        res.status(500).json({ message: 'Server error', error });
    }
};


// Claim Reward (Mining) - Auto-Approve for MVP
export const claimReward = async (req: AuthRequest, res: Response) => {
    try {
        const { rigId, amount } = req.body;
        const userId = req.userId;

        if (!amount || amount <= 0) return res.status(400).json({ message: 'Invalid amount' });

        const user = await User.findById(userId);
        if (!user) return res.status(404).json({ message: 'User not found' });

        // Verify Rig Ownership (Assuming Rig stores ownerId as String, based on Rig.ts)
        // Also Rig.ts has `ownerId`, `id` is autogenerated _id. Frontend passes `rigId` which usually is `_id`.
        const rig = await Rig.findOne({ _id: rigId, ownerId: userId });
        if (!rig) return res.status(404).json({ message: 'Rig not found or not owned' });

        user.balance += amount;
        await user.save();

        // Update Rig (Use Mongoose 'set' or direct assignment if Rig model allows)
        // Rig.ts doesn't explicitly show `lastClaimAt` in interface/schema in the VIEWED file.
        // Step 3702 showed `Rig.ts` content. 
        // `IRig` has: ownerId, name, image, investment, dailyProfit, purchaseDate, expiresAt, rarity, level, slots, status.
        // IT DOES NOT HAVE `lastClaimAt`.
        // This is a discrepancy. `PlayerDashboard` uses `lastClaimAt`.
        // `MockDB` had `lastClaimAt`.
        // If I want to persist it, I must ADD it to the Schema.

        // I will add `lastClaimAt` to Rig Schema first, OR just ignore it in backend for now (stateless claim?).
        // But preventing double claim needs `lastClaimAt`.
        // I should add it to Rig.ts.

        const claim = await ClaimRequest.create({
            userId,
            username: user.username,
            rigId,
            rigName: rig.name,
            amount,
            status: 'APPROVED'
        });

        res.json({ message: 'Claim successful', newBalance: user.balance, claim });
    } catch (error) {
        res.status(500).json({ message: 'Server error', error });
    }
};

// ... existing exports
